package main

import (
	"fmt"
	"os"
	"regexp"
	"strings"
)

// Code generated by GPT :)
// Prompt:
// "In Golang using a Regex. I need a parser that will split a line into strings separated by whitespaces but should ignore whitespaces inside single or double quotes."
// "It should also remove leading and trailling spaces, tabs, newlines and carriage returns on each string"
func ParseInput(input string) []string {
	// Define the regex pattern
	re := regexp.MustCompile(`('[^']*'|"[^"]*")|[^\s]+`)

	// Find all matches
	matches := re.FindAllString(input, -1)

	// Trim spaces, tabs, newlines and carriage returns on each string
	for i, match := range matches {
		matches[i] = strings.TrimSpace(match)
		matches[i] = strings.Replace(matches[i], "'", "", -1)
	}

	return matches
}

// Also generated by GPT but less cryptic
func GetPipeSeparatedCommands(tokens []string) [][]string {
	var result [][]string
	var currentSubSlice []string

	for _, str := range tokens {
		if str == "|" {
			// If we encounter the delimiter, save the current subslice and start a new one
			if len(currentSubSlice) > 0 {
				result = append(result, currentSubSlice)
				currentSubSlice = []string{}
			}
		} else {
			// Add string to the current subslice
			currentSubSlice = append(currentSubSlice, str)
		}
	}

	// Don't forget to append the last subslice if it exists
	if len(currentSubSlice) > 0 {
		result = append(result, currentSubSlice)
	}

	return result
}

func getUser() string {
	if user := os.Getenv("USER"); user != "" {
		return user
	}
	return "gary"
}

func getHost() string {
	if hostname, err := os.Hostname(); err == nil {
		return hostname
	}
	return "host"
}

func getUnexpandedCwd() string {
	dir, err := os.Getwd()
	if err != nil {
		return ""
	}
	homeDir := os.Getenv("HOME")
	homeDir = strings.TrimRight(homeDir, "/")
	return strings.Replace(dir, homeDir, "~", -1)
}

func expandHome(path string) string {
	homeDir := os.Getenv("HOME")
	if homeDir == "" {
		return ""
	}
	homeDir = strings.TrimRight(homeDir, "/")
	return strings.Replace(path, "~", homeDir, -1)
}

// Searches for executable file with name `cmd` in user PATH and returns path to file if it exists
func findInPath(cmd string) string {
	pathEnv := os.Getenv("PATH")
	paths := strings.Split(pathEnv, ":")
	for _, p := range paths {
		dir, err := os.ReadDir(p)
		if err != nil {
			continue
		}
		for _, f := range dir {
			if f.Name() != cmd {
				continue
			}
			if f.IsDir() {
				continue
			}
			info, err := f.Info()
			if err != nil {
				continue
			}
			if info.Mode()&0111 == 0 { // check if executable by anyone (0b1001001)
				continue
			}
			return fmt.Sprintf("%s/%s", p, f.Name())
		}
	}
	return ""
}
